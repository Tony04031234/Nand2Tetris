// projects/09/segment/Segment.jack

/**
 *  Implements a graphical Snek.
 *  The Snek is composed of a head and a tail. The head draws the Snek as
 *  it moves, and the tail undraws the Snek. The head takes its movements
 *  directly from user input, whereas the tail follows a queue of moves
 *  fed from user input, where the queue is as long as the snake.
 */
class Snek {

    field Segment m_head;
    field Segment m_tail;
    field Array m_segments;
 
    field int m_length;
    field int m_movePtr;

    field Array m_movements;

    constructor Snek new(int length) {
        var int iter;
        let m_length = length;

        // set up movement queue
        let m_movements = Array.new(500);
        let iter = 0;        
        while (iter < 500) {
            let m_movements[iter] = 0;
            let iter = iter + 1;
        }
        let m_movePtr = m_length;

        // set up segments
        let m_segments = Array.new(500);
        // head
        let m_segments[0] = Segment.new(200, 100, 5, /* isHead = */ true,  /* isTail */ false, m_length); 
        // body
        let iter = 1;
        while (iter < (length - 1)) {
            let m_segments[iter] = Segment.new(200, 100, 5, false, false, ((m_length - 1) - iter));
            let iter = iter + 1;
        }
        // tail
        let m_segments[m_length - 1] = Segment.new(200, 100, 5, /* isHead = */ false, /* isTail */ true, 0); 

        return this;
    }

    method void dispose() {
        do m_segments.dispose();
        do m_tail.dispose();
        do Memory.deAlloc(this);
        return;
    }

    method void moveUp() {
        do addMove(1);
        do moveBody();
        return;
    }

    method void moveDown() {
        do addMove(2); 
        do moveBody();
        return;
    }

    method void moveLeft() {
        do addMove(3); 
        do moveBody();
        return;
    }

    method void moveRight() {
        do addMove(4); 
        do moveBody();
        return;
    }

    method void addMove(int direction) {
        let m_movements[m_movePtr] = direction;
        let m_movePtr = m_movePtr + 1;
        if (m_movePtr = 500) {
            let m_movePtr = 0;
        }
        return;
    }

    method void moveBody() {
        var int direction;
        var Segment segment;
        var int segmentMove;
        var int i;
    
        let i = 0;
        while (i < m_length) {
            let segment = m_segments[i];
            let segmentMove = segment.getNextMove();
            let direction = m_movements[segmentMove];

            if (direction = 1) {
                do segment.moveUp();
            }
            if (direction = 2) {
                do segment.moveDown();
            }
            if (direction = 3) {
                do segment.moveLeft();
            }
            if (direction = 4) {
                do segment.moveRight();
            }

            do segment.setNextMove(segmentMove + 1);
            let i = i + 1;
        }
        return;
    }
    
    /** Enlarge the Snek by delaying the tail */
    method void grow() {
        // add new tail segment
        var Segment oldTail;
        var int tempX, tempY, tempMovePtr;
        // put it in the same spot as the old tail with a move ptr one behind, and explicitly set that 
        // segment of the move array to 0
        let oldTail = m_segments[m_length - 1]; 
        do oldTail.notTail();
        let tempX = oldTail.getX();
        let tempY = oldTail.getY();
        let tempMovePtr = oldTail.getNextMove() - 1;
        if (tempMovePtr = -1) {
            let tempMovePtr = 500;
        }
        let m_movements[tempMovePtr] = 0; // delay for one move
        let m_segments[m_length] = Segment.new(tempX, tempY, 5, /* isHead = */ false, /* isTail */ true, tempMovePtr);

        // set old tail to regular segment
        let oldTail = m_segments[m_length - 1];
        do oldTail.notTail(); 

        let m_length = m_length + 1;
        return;
    }

} // class Snek

