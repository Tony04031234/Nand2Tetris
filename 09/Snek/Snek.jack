// projects/09/segment/Segment.jack

/**
 *  Implements a graphical Snek.
 *  The Snek is composed of a head and a tail. The head draws the Snek as
 *  it moves, and the tail undraws the Snek. The head takes its movements
 *  directly from user input, whereas the tail follows a queue of moves
 *  fed from user input, where the queue is as long as the snake.
 */
class Snek {

    field Segment m_head;
    field Segment m_tail;
    field Array m_segments;
 
    field int m_length;
    field int m_movePtr;

    field Array m_movements;

    constructor Snek new(int length) {
        var int iter;
        let m_length = length;

        // set up movement queue
        let m_movements = Array.new(500);
        let iter = 0;        
        while (iter < 500) {
            let m_movements[iter] = 0;
            let iter = iter + 1;
        }
        let m_movePtr = m_length;

        // set up segments
        let m_segments = Array.new(500);
        // head
        let m_segments[0] = Segment.new(200, 100, 5, /* isHead = */ true,  /* isTail */ false, m_length); 
        // body
        let iter = 1;
        while (iter < (length - 1)) {
            let m_segments[iter] = Segment.new(200, 100, 5, false, false, ((m_length - 1) - iter));
            let iter = iter + 1;
        }
        // tail
        let m_segments[m_length - 1] = Segment.new(200, 100, 5, /* isHead = */ false, /* isTail */ true, 0); 

        return this;
    }

    method void dispose() {
        do m_segments.dispose();
        do m_tail.dispose();
        do Memory.deAlloc(this);
        return;
    }

    method void moveUp() {
        do addMove(1);
        do moveBody();
        return;
    }

    method void moveDown() {
        do addMove(2); 
        do moveBody();
        return;
    }

    method void moveLeft() {
        do addMove(3); 
        do moveBody();
        return;
    }

    method void moveRight() {
        do addMove(4); 
        do moveBody();
        return;
    }

    method void addMove(int direction) {
        let m_movements[m_movePtr] = direction;
        let m_movePtr = m_movePtr + 1;
        if (m_movePtr = 100) {
            let m_movePtr = 0;
        }
        return;
    }

    method void moveBody() {
        var int direction;
        var Segment segment;
        var int segmentMove;
        var int i;
    
        let i = 0;
        while (i < m_length) {
            let segment = m_segments[i];
            let segmentMove = segment.getNextMove();
            let direction = m_movements[segmentMove];

            if (direction = 1) {
                do segment.moveUp();
            }
            if (direction = 2) {
                do segment.moveDown();
            }
            if (direction = 3) {
                do segment.moveLeft();
            }
            if (direction = 4) {
                do segment.moveRight();
            }

            do segment.setNextMove(segmentMove + 1);
            let i = i + 1;
        }
        return;
    }
    
    /** Enlarge the Snek by delaying the tail */
    method void grow() {
        // let m_segments[m_length - 1] = Segment.new(
        // The tail is being delayed by a MOVE, not by moving its pointer back
        // we need to actually move its pointer backwards. But that will make it repeat the move
        // it did last, which will be incorrect...
        // New strategy: add a new segment at the end, make that the tail, make the tail a non-tail?
        do addMove(0);
        do addMove(0);
        return;
    }

} // class Snek

