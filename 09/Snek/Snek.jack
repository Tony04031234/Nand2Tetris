// projects/09/segment/Segment.jack

/**
 *  Implements a graphical Snek.
 *  The Snek is composed of a head and a tail. The head draws the Snek as
 *  it moves, and the tail undraws the Snek. The head takes its movements
 *  directly from user input, whereas the tail follows a queue of moves
 *  fed from user input, where the queue is as long as the snake.
 */
class Snek {

    field Segment m_head;
    field Segment m_tail;
    field Array m_segments;
 
    field int m_length;
    field int m_movePtr;

    field Array m_movements;

    constructor Snek new(int length) {
        var int iter;
        let m_length = length;

        // set up movement queue
        let m_movements = Array.new(500);
        let iter = 0;        
        while (iter < 500) {
            let m_movements[iter] = 0;
            let iter = iter + 1;
        }
        let m_movePtr = m_length;

        // set up segments
        let m_head = Segment.new(200, 100, 5, /* isHead = */ true, 0);
        let m_tail = Segment.new(200, 100, 5, /* isHead = */ false, 0);
        let m_segments = Array.new(500);
        let iter = 0;
        while (iter < (length - 1)) {
            let m_segments[iter] = Segment.new(200, 100, 5, false, ((m_length - 1) - iter));
            let iter = iter + 1;
        }

        return this;
    }

    method void dispose() {
        do m_head.dispose();
        do m_tail.dispose();
        do Memory.deAlloc(this);
        return;
    }

    method void moveUp() {
        do m_head.moveUpAndDraw();
        do addMove(1);
        do moveTail();
        do moveBody();
        return;
    }

    method void moveDown() {
        do addMove(2); 
        do m_head.moveDownAndDraw();
        do moveTail();
        do moveBody();
        return;
    }

    method void moveLeft() {
        do m_head.moveLeftAndDraw();
        do addMove(3); 
        do moveTail();
        do moveBody();
        return;
    }

    method void moveRight() {
        do m_head.moveRightAndDraw();
        do addMove(4); 
        do moveTail();
        do moveBody();
        return;
    }

    method void addMove(int direction) {
        let m_movements[m_movePtr] = direction;
        let m_movePtr = m_movePtr + 1;
        if (m_movePtr = 100) {
            let m_movePtr = 0;
        }
        return;
    }

    method void moveTail() {
        var int direction;
        var int segmentMove;
        let segmentMove = m_tail.getNextMove();
        let direction = m_movements[segmentMove];
        
        if (direction = 1) {
            do m_tail.moveUpAndDraw();
        }
        if (direction = 2) {
            do m_tail.moveDownAndDraw();
        }
        if (direction = 3) {
            do m_tail.moveLeftAndDraw();
        }
        if (direction = 4) {
            do m_tail.moveRightAndDraw();
        }

        do m_tail.setNextMove(segmentMove + 1);

        return;
    }

    method void moveBody() {
        var int direction;
        var Segment segment;
        var int segmentMove;
        var int i;
    
        let i = 0;
        while (i < (m_length - 1)) {
            let segment = m_segments[i];
            let segmentMove = segment.getNextMove();
            let direction = m_movements[segmentMove];

            if (direction = 1) {
                do segment.moveUp();
            }
            if (direction = 2) {
                do segment.moveDown();
            }
            if (direction = 3) {
                do segment.moveLeft();
            }
            if (direction = 4) {
                do segment.moveRight();
            }

            do segment.setNextMove(segmentMove + 1);
            let i = i + 1;
        }
        return;
    }
    
    /** Enlarge the Snek by delaying the tail */
    method void grow() {
        do addMove(0);
        do addMove(0);
        return;
    }

} // class Snek

